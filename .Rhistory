Obs_Catch_Comp_noAE[d-(fyear_dat-1),]<-rmultinom(n=1,size=N_Comp[d], prob=OM$Caa[d,])
Obs_Index[d-(fyear_dat-1)]<-rlnorm(1, meanlog=log(sum(OM$Naa[d,]*((1-exp(-OM$Zaa[d,]))/OM$Zaa[d,])*OM$Sel*OM$Waa)*q_index), sdlog=sd_index)
#Getting observed data with Ageing error
#Another sampler is needed to get data in integers
#and needs to be done on individual fish to remember the year, true age, and coded age for later CKMR calcs
for (a in 1:length(OM$fage:OM$lage)){
if(Obs_Catch_Comp_noAE[d-(fyear_dat-1),a]>0){
for(j in 1:Obs_Catch_Comp_noAE[d-(fyear_dat-1),a]){
ages_long<-rbind.data.frame(ages_long,data.frame(year=d, true_age=a-1, coded_age=which(rmultinom(1,size=1,prob=AE_mat[a,])>0)-1))  #-1 necessary to account for age zeroes
}
}
}
Obs_Catch_Comp[d-(fyear_dat-1),]<-table(factor(ages_long$coded_age[ages_long$year==d],levels=OM$fage:OM$lage))
}
ages_long<-ages_long[-1,] #Just taking the NA out
##################################
#Simulator for both HSP and POP
##################################
library(microbenchmark)
library(purrr)
#Simulating the data
ages <- OM$fage:OM$lage          #a vector of the ages
n_ckmr<-round(N_Comp_CKMR*prop_ckmr) #the number of ckmr samples
samples<-data.frame(samp_year=NA, true_age=NA, coded_age=NA)
if (prop_ckmr==1){
samples <- data.frame(samp_year=ages_long$year[ages_long$year %in% fyear_ckmr:lyear_ckmr], true_age=ages_long$true_age[ages_long$year %in% fyear_ckmr:lyear_ckmr], coded_age=ages_long$coded_age[ages_long$year %in% fyear_ckmr:lyear_ckmr])
}else if (prop_ckmr!=1){
for(i in 1:length(fyear_ckmr:lyear_ckmr)){
samples <- rbind.data.frame(samples,ages_long[sample(which(ages_long$year == (fyear_ckmr:lyear_ckmr)[i]), size = n_ckmr, replace = FALSE),] )
}
}
samples <- cbind.data.frame(samples, true_born_year = samples$samp_year - samples$true_age, coded_born_year = samples$samp_year - samples$coded_age)    #From the age and sampling year, calculate the year it was born in.
#The total reproductive output at the time it was born
Tot_reprod <- rep(NA, length(samples$true_born_year))
Tot_reprod[which(samples$true_born_year>0)] <- OM$SSB[samples$true_born_year[which(samples$true_born_year>0)]]
Tot_reprod[which(samples$true_born_year<1)] <- OM$SSB0
samples <- cbind.data.frame(samples, Tot_reprod = Tot_reprod)                         #The total reproductive output at the time it was born
samples<-aggregate(rep(1,nrow(samples)),by=list(samp_year=samples$samp_year,true_age=samples$true_age,coded_age=samples$coded_age,true_born_year=samples$true_born_year,coded_born_year=samples$coded_born_year,Tot_reprod=samples$Tot_reprod), FUN=sum)
colnames(samples)<-c("samp_year","true_age","coded_age","true_born_year","coded_born_year","Tot_reprod","reps")
samples<-samples[order(samples$samp_year,samples$true_age,samples$coded_age,samples$true_born_year,samples$coded_born_year,samples$Tot_reprod),]
pairs<-do.call(cbind.data.frame,Map(expand.grid,samples,samples))
colnames(pairs)<-c("samp_year.old","samp_year.young","true_age.old","true_age.young","coded_age.old","coded_age.young","true_born_year.old","true_born_year.young","coded_born_year.old","coded_born_year.young","Tot_reprod.old","Tot_reprod.young","reps.old","reps.young") #naming the columns
#Older sibling has to be older than younger, as does parent.
pairs <- pairs[c(pairs$true_born_year.old < pairs$true_born_year.young),]
pairs <- pairs[,c("samp_year.young","true_age.young","coded_age.young","true_born_year.young","coded_born_year.young","Tot_reprod.young","reps.young","samp_year.old","true_age.old","coded_age.old","true_born_year.old","coded_born_year.old","Tot_reprod.old","reps.old")] #just reordering the columns
pairs <- cbind.data.frame(pairs, true_age_diff = pairs$true_born_year.young-pairs$true_born_year.old, coded_age_diff = pairs$coded_born_year.young-pairs$coded_born_year.old, times=pairs$reps.young*pairs$reps.old)
#Rewrote using multinomial (and binomial. rather than bernoulli), because you can't have too many samples it gets too complex. With AE now need to keep track of the ages (in particular the age of the younger bc age of older is findable)
collapsed_pairs<-aggregate.data.frame(x=pairs$times, by=list(pairs$true_born_year.young,pairs$true_age_diff,pairs$samp_year.old, pairs$coded_born_year.young, pairs$coded_age_diff,pairs$coded_age.young,pairs$coded_age.old), FUN=sum)
colnames(collapsed_pairs)<-c("true_born_year.young", "true_age_diff","samp_year.old","coded_born_year.young","coded_age_diff","coded_age.young","coded_age.old","times")
#Now for loop through the samples, and now we only consider the true ages (the coded stuff is just for bookkeeping and later data)
surv_prob<-matrix(0, nrow=nrow(collapsed_pairs), ncol=(OM$lage+1))
HSP_calcs<-matrix(0, nrow=nrow(collapsed_pairs), ncol=(OM$lage+1))
lxf<-list()
for (i in 1:nrow(collapsed_pairs)){
#Probability you were alive in the year of the first born and survived to the year of the second born
if(collapsed_pairs$true_age_diff[i]>0){ #Your true age difference has to be > 0
lxf[[i]]<-matrix(NA,nrow=collapsed_pairs$true_age_diff[i],ncol=(OM$lage+1)+collapsed_pairs$true_age_diff[i]-1)
if(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]>0){
lxf[[i]][1,1:(OM$lage+1)]<-exp(-(OM$Maa+OM$Faa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i],]))
} else if (collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]<1){ #to account for unfished years
lxf[[i]][1,1:(OM$lage+1)]<-exp(-OM$Maa)
}
if(collapsed_pairs$true_age_diff[i]>1){
for (y in 1:(collapsed_pairs$true_age_diff[i]-1)){        #Loop through the years the parent has to survive (1st year has 1 for survival)
for (j in 1:((OM$lage+1)+collapsed_pairs$true_age_diff[i]-2)){   #Loop through mature ages in the year of the first born
if(j<(OM$lage+1)+1){ #if we are not in plus group
if(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]>0){
lxf[[i]][y+1,j+1] <- lxf[[i]][y,j]*exp(-(OM$Maa[j]+OM$Faa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]+y,j]))  #(y-1) is to account for the year in pop model
} else if (collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]<1){ #to account for unfished years
lxf[[i]][y+1,j+1] <- lxf[[i]][y,j]*exp(-OM$Maa[j])
}} else if (j>(OM$lage+1)){
if(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]>0){
lxf[[i]][y+1,j+1] <- lxf[[i]][y,j]*exp(-(OM$Maa[OM$lage+1]+OM$Faa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]+y,(OM$lage+1)]))  #collapsed_pairs$born_year.young[i]-collapsed_pairs$age_diff[i] is to get the birth year of first born
} else if (collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]<1){ #to account for unfished years
lxf[[i]][y+1,j+1] <- lxf[[i]][y,j]*exp(-OM$Maa[OM$lage+1])
}
}
}
}
}
#Probability you survived to the year of the second born (surviving the year of first born and all the way through the year before the second born)
#From the age of the parent at the time of the first born
surv_prob[i,]<-lxf[[i]][collapsed_pairs$true_age_diff[i],collapsed_pairs$true_age_diff[i]:((OM$lage+1)+collapsed_pairs$true_age_diff[i]-1)]
#Ok so now it is the number (fecundity) that could have given birth to the first born / total reproductive output  * survival to second born * (fecundity of age at second born / total reproductive output at time of second born)
for(j in 2:(OM$lage+1)){ #you can't have been the parent at age 0
if ((j+collapsed_pairs$true_age_diff[i])<=(OM$lage+1)){ #If we are not in the plus group
if(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]>0){ # if we're not in unfished years
HSP_calcs[i,j] <-  ( (OM$Naa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i],j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]] ) * surv_prob[i,j]  * (4 * OM$Mat[j+collapsed_pairs$true_age_diff[i]]*OM$Waa[j+collapsed_pairs$true_age_diff[i]] / OM$SSB[collapsed_pairs$true_born_year.young[i]])  #4 is for MHSP + FHSP
#          HSP_calcs[i,j] <- 2 * (( (0.5*OM$Naa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i],j]*OM$Mat[j]*OM$Waa[j]) / (0.5*OM$SSB[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]]) ) * surv_prob[i,j]  * (OM$Mat[j+collapsed_pairs$true_age_diff[i]]*OM$Waa[j+collapsed_pairs$true_age_diff[i]] / (0.5*OM$SSB[collapsed_pairs$true_born_year.young[i]])))  #4 is for MHSP + FHSP
} else if (collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]<1){ #if we are in unfished years
if(collapsed_pairs$true_born_year.young[i]>0){ #if second born is not in unfished years
HSP_calcs[i,j] <-  ( (OM$N0aa[j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB0 ) * surv_prob[i,j]  * (4 * OM$Mat[j+collapsed_pairs$true_age_diff[i]]*OM$Waa[j+collapsed_pairs$true_age_diff[i]] / OM$SSB[collapsed_pairs$true_born_year.young[i]])  #4 is for MHSP + FHSP
} else if (collapsed_pairs$true_born_year.young[i]<1){ #if second born is in unfished years
HSP_calcs[i,j] <-  ( (OM$N0aa[j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB0 ) * surv_prob[i,j]  * (4 * OM$Mat[j+collapsed_pairs$true_age_diff[i]]*OM$Waa[j+collapsed_pairs$true_age_diff[i]] / OM$SSB0)  #4 is for MHSP + FHSP
}}
} else if (j+collapsed_pairs$true_age_diff[i]>(OM$lage+1)){ #Now if we are in plus group
if(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]>0){ #if we're not in unfished years
HSP_calcs[i,j] <-  ( (OM$Naa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i],j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]] ) * surv_prob[i,j]  * (4 * OM$Mat[(OM$lage+1)]*OM$Waa[(OM$lage+1)] / OM$SSB[collapsed_pairs$true_born_year.young[i]])  #4 is for MHSP + FHSP
#          HSP_calcs[i,j] <- 2 * (( (0.5*OM$Naa[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i],j]*OM$Mat[j]*OM$Waa[j]) / (0.5*OM$SSB[collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]] )) * surv_prob[i,j]  * (OM$Mat[(OM$lage+1)]*OM$Waa[(OM$lage+1)] / (0.5*OM$SSB[collapsed_pairs$true_born_year.young[i]])))  #4 is for MHSP + FHSP
} else if (collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i]<1){ #if we are in unfished years
if(collapsed_pairs$true_born_year.young[i]>0){ #if second born is not in unfished years
HSP_calcs[i,j] <-  ( (OM$N0aa[j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB0 ) * surv_prob[i,j]  * (4 * OM$Mat[(OM$lage+1)]*OM$Waa[(OM$lage+1)] / OM$SSB[collapsed_pairs$true_born_year.young[i]])  #4 is for MHSP + FHSP
} else if (collapsed_pairs$true_born_year[i]<1){ #if second born is in unfished years
HSP_calcs[i,j] <-  ( (OM$N0aa[j]*OM$Mat[j]*OM$Waa[j]) / OM$SSB0 ) * surv_prob[i,j]  * (4 * OM$Mat[(OM$lage+1)]*OM$Waa[(OM$lage+1)] / OM$SSB0)  #4 is for MHSP + FHSP
}}
}
}
}
}
#Then we sum over all the ages to get the HSP probability for that given data pair
collapsed_pairs$HSP_prob <- rowSums(HSP_calcs)
####################
#Now POP calcs
####################
#Now for loop through the samples
collapsed_pairs$prob_POP<-0
for (i in 1:nrow(collapsed_pairs)){
if(collapsed_pairs$true_age_diff[i]>0){ #Your true age difference has to be > 0
#Ok so the fecundity based on the age of the potential parent / (0.5 * the total reproductive output of the population at the time of juves birth )
if(collapsed_pairs$true_born_year.young[i]>0){  #if not in unfished territory
collapsed_pairs$prob_POP[i]<- 2*(OM$Mat[collapsed_pairs$true_age_diff[i]+1]*OM$Waa[collapsed_pairs$true_age_diff[i]+1] / sum( OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa ))
} else if(collapsed_pairs$true_born_year.young[i]<1){
collapsed_pairs$prob_POP[i]<- 2*(OM$Mat[collapsed_pairs$true_age_diff[i]+1]*OM$Waa[collapsed_pairs$true_age_diff[i]+1] / sum( OM$N0aa*OM$Mat*OM$Waa ))
}
}
}#Don't need to consider plus group calcs bc max age diff will be 25
#if the sample year of the older is the same year as born year of younger, multiply by 50%
collapsed_pairs$prob_POP<-ifelse(collapsed_pairs$samp_year.old == collapsed_pairs$true_born_year.young,0.5*collapsed_pairs$prob_POP,collapsed_pairs$prob_POP)
# A potential parent has to have been sampled after or on the year of youngs birth, because sampling is lethal
collapsed_pairs$prob_POP<-ifelse(collapsed_pairs$samp_year.old >= collapsed_pairs$true_born_year.young,collapsed_pairs$prob_POP,0)
####################################
#Now GGP Probabilities
####################################
#Now for loop through the samples
collapsed_pairs$prob_GGP<-0
for (i in 1:nrow(collapsed_pairs)){
#Your true age difference has to be > 0,
if(collapsed_pairs$true_age_diff[i]>0){
for (k in 1:OM$lage){  #Looping through potential ages of potential parent. you can't have been the parent at age 0
#sample year of older must be greater than birth year of the parent
if(collapsed_pairs$samp_year.old[i]>(collapsed_pairs$true_born_year.young[i]-k)){
#age of grandparent at year of parents birth must be positive
if(((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) > 0 & ((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) < (OM$lage+1)){ #if we're not in plus group, and age of grandparent at year of parents birth must be positive
if((collapsed_pairs$true_born_year.young[i]-k)>0 & collapsed_pairs$true_born_year.young[i]>0){  #if not in unfished territory
#P(GGP)=2 * sum over parent ages (Naa[birth year of younger,age of potential parent] * Fec[age of potential parent at time of youngers birth]/SSB[birth year of younger] * Fec[age of grandparent at time of parents birth]/(0.5*SSB[year of potential parents birth]) )
#So the birth year of the potential parent of the younger is the birth year of younger - age of parent at time of youngers birth
#The age of the grandparent at the time of the parents birth is the birth year of the parent - the birth year of the grandparent
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$Naa[collapsed_pairs$true_born_year.young[i]-k,]*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]>0){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]<1){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$N0aa[,k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$N0aa*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
}
#Now if we are in plus group territory. Same calcs just plus group
} else if(((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) > OM$lage){
if((collapsed_pairs$true_born_year.young[i]-k)>0 & collapsed_pairs$true_born_year.young[i]>0){  #if not in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$Naa[collapsed_pairs$true_born_year.young[i]-k,]*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]>0){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]<1){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] +
OM$N0aa[,k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$N0aa*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
}
}
}
#######Instead if the sample year of older is equal to the birth year of the potential parent
if(collapsed_pairs$samp_year.old[i]==(collapsed_pairs$true_born_year.young[i]-k)){
#age of grandparent at year of parents birth must be positive
if(((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) > 0 & ((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) < (OM$lage+1)){ #if we're not in plus group, and age of grandparent at year of parents birth must be positive
if((collapsed_pairs$true_born_year.young[i]-k)>0 & collapsed_pairs$true_born_year.young[i]>0){  #if not in unfished territory
#P(GGP)=2 * sum over parent ages (Naa[birth year of younger,age of potential parent] * Fec[age of potential parent at time of youngers birth]/SSB[birth year of younger] * Fec[age of grandparent at time of parents birth]/(0.5*SSB[year of potential parents birth]) )
#So the birth year of the potential parent of the younger is the birth year of younger - age of parent at time of youngers birth
#The age of the grandparent at the time of the parents birth is the birth year of the parent - the birth year of the grandparent
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$Naa[collapsed_pairs$true_born_year.young[i]-k,]*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]>0){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]<1){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$N0aa[,k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$N0aa*OM$Mat*OM$Waa)) *
((OM$Mat[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1]*OM$Waa[(collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
}
#Now if we are in plus group territory. Same calcs just plus group
} else if(((collapsed_pairs$true_born_year.young[i]-k)-(collapsed_pairs$true_born_year.young[i]-collapsed_pairs$true_age_diff[i])) > OM$lage){
if((collapsed_pairs$true_born_year.young[i]-k)>0 & collapsed_pairs$true_born_year.young[i]>0){  #if not in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$Naa[collapsed_pairs$true_born_year.young[i]-k,]*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]>0){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$Naa[collapsed_pairs$true_born_year.young[i],k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$Naa[collapsed_pairs$true_born_year.young[i],]*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
} else if((collapsed_pairs$true_born_year.young[i]-k)<1 & collapsed_pairs$true_born_year.young[i]<1){  #if in unfished territory
collapsed_pairs$prob_GGP[i]<- collapsed_pairs$prob_GGP[i] + 0.5 *
OM$N0aa[,k+1] *
((OM$Mat[k+1]*OM$Waa[k+1])/sum(OM$N0aa*OM$Mat*OM$Waa)) *
((OM$Mat[OM$lage+1]*OM$Waa[OM$lage+1])/(0.5*sum(OM$N0aa*OM$Mat*OM$Waa)))
}
}
}
}
}
}
#Multiplying by two for the probability of MGGP or PGGP
collapsed_pairs$prob_GGP<-2*collapsed_pairs$prob_GGP
collapsed_pairs$n_UP<-collapsed_pairs$n_HSPorGGP<-collapsed_pairs$n_POP<-NA
for (m in 1:nrow(collapsed_pairs)){
collapsed_pairs[m,c("n_UP","n_HSPorGGP","n_POP")]<-t(rmultinom(1, size=collapsed_pairs$times[m], prob=c(1-((collapsed_pairs$HSP_prob[m]+collapsed_pairs$prob_GGP[m])*pi_nu+collapsed_pairs$prob_POP[m]),(collapsed_pairs$HSP_prob[m]+collapsed_pairs$prob_GGP[m])*pi_nu,collapsed_pairs$prob_POP[m])))
}
#ordering the counts by coded year born and then the coded age difference (for data purposes)
collapsed_pairs<-collapsed_pairs[order(collapsed_pairs$coded_born_year.young,collapsed_pairs$coded_age_diff,collapsed_pairs$true_born_year.young,collapsed_pairs$true_age_diff),]
collapsed_data<-aggregate.data.frame(x=collapsed_pairs[,c("times", "n_UP", "n_HSPorGGP","n_POP")], by=list(collapsed_pairs$coded_born_year.young,collapsed_pairs$coded_age_diff,collapsed_pairs$samp_year.old,collapsed_pairs$coded_age.young,collapsed_pairs$coded_age.old), FUN=sum)
colnames(collapsed_data)<-c("coded_born_year.young", "coded_age_diff","samp_year.old","coded_age.young","coded_age.old","times", "n_UP", "n_HSPorGGP","n_POP")
sim_vals <- list(samples = samples, pairs=pairs, pair_counts = collapsed_pairs, pair_data = collapsed_data[,c("coded_born_year.young", "coded_age_diff", "samp_year.old","coded_age.young","coded_age.old","n_UP", "n_HSPorGGP","n_POP","times")])
return(list(OM=OM,dat_seed=dat_seed,sd_catch=sd_catch,N_Comp_preCKMR=N_Comp_preCKMR,N_Comp_CKMR=N_Comp_CKMR,q_index=q_index,sd_index=sd_index,fyear_dat=fyear_dat,lyear_dat=lyear_dat,prop_ckmr=prop_ckmr,fyear_ckmr=fyear_ckmr,lyear_ckmr=lyear_ckmr,pi_nu=pi_nu,AE_mat=AE_mat,
#            pair_counts=sim_vals$pair_counts, #too memory intensive to upload (and don't use for anything)
Obs_Catch=Obs_Catch,
Obs_Catch_Comp=Obs_Catch_Comp,
Obs_Index=Obs_Index,
#CKMR HSP data
born_year_old=sim_vals$pair_data$coded_born_year.young-sim_vals$pair_data$coded_age_diff,
age_diff=sim_vals$pair_data$coded_age_diff,
n_ckmr=sim_vals$pair_data$times,
k_ckmr_hsporggp=sim_vals$pair_data$n_HSPorGGP,
#CKMR POP
born_year_young=sim_vals$pair_data$coded_born_year.young,
k_ckmr_pop=sim_vals$pair_data$n_POP,
samp_year_old=sim_vals$pair_data$samp_year.old,
coded_age_young=sim_vals$pair_data$coded_age.young,
coded_age_old=sim_vals$pair_data$coded_age.old  ))
}
wd<-"C:/Users/fischn/Documents/GitHub/CKMR_Project/"
AEs<-readRDS("C:/Users/fischn/Documents/GitHub/CKMR_Project/AE_mat_list.RData")
N_sim<-100
Cod_wdat<-Flatfish_wdat<-Sardine_wdat<-list()
#N_comp_preCKMR<-100
N_comp_preCKMR<-c(30,rep(0,9),40,rep(0,9),50,rep(0,4),60,rep(0,4),70,rep(0,4),80,rep(0,4),90,rep(0,4),rep(100,30))
N_comp_CKMR<-5000
sd_catch<-0.05
sd_index<-0.25
fyear_dat<-26
lyear_dat<-100
prop_ckmr<-1
fyear_ckmr<-81
lyear_ckmr<-100
pi_nu<-0.736
progress_bar<-TRUE
for (s in 1:1){
Sardine_wdat[[s]] <-Get_Data(OM=Sardine_runs[[s]], dat_seed=s,fyear_dat=fyear_dat,lyear_dat=lyear_dat,sd_catch=sd_catch,N_Comp_preCKMR=N_comp_preCKMR,N_Comp_CKMR=N_comp_CKMR,q_index=0.0001,sd_index=sd_index,prop_ckmr=prop_ckmr,fyear_ckmr=fyear_ckmr,lyear_ckmr=lyear_ckmr,pi_nu=pi_nu,AE_mat="identity")
}
#TMB Section
library(TMB)
setwd(wd)
#Compile and load model
compile("CKMRmultinom_POP_HSP_GPP_Fisch_wAE.cpp")
OM<-Sardine_wdat[[1]]
dat<-list(fyear=OM$OM$fyear, lyear=75, fage=OM$OM$fage, lage=OM$OM$lage,
years=OM$OM$fyear:75, ages=OM$OM$fage:OM$OM$lage,
obs_harv=OM$Obs_Catch,
obs_index=OM$Obs_Index,
obs_fishery_comp=OM$Obs_Catch_Comp/rowSums(OM$Obs_Catch_Comp),
SS_fishery=rowSums(OM$Obs_Catch_Comp),
Mat=OM$OM$Mat,
Laa=OM$OM$Laa,
Waa=OM$OM$Waa,
#CKMR
coded_born_year_old=OM$born_year_old-(OM$fyear_dat-1),
coded_age_diff=OM$age_diff,
n_ckmr=OM$n_ckmr,
k_ckmr_hsporggp=OM$k_ckmr_hsporggp,
coded_born_year_young=OM$born_year_young-(OM$fyear_dat-1),
k_ckmr_pop=OM$k_ckmr_pop,
samp_year_coded_old=OM$samp_year_old-(OM$fyear_dat-1),
coded_age_one=OM$coded_age_young,
coded_age_two=OM$coded_age_old,
coded_one_min=rep(0,length(OM$k_ckmr_pop)),
coded_one_max=rep(15,length(OM$k_ckmr_pop)),
coded_two_min=rep(0,length(OM$k_ckmr_pop)),
coded_two_max=rep(15,length(OM$k_ckmr_pop)),
#Switch for whether to use a data source or not, 0=no, 1=yes
Lamda_Harvest=1,
Lamda_Comp=1,
Lamda_Index=1,
Lamda_CKMR=1,
AE_mat=OM$AE_mat,
pi_nu=OM$pi_nu)
#Parameters
par <- list(log_M=log(OM$OM$Mref),
log_q=log(OM$q_index),
log_recruit_devs_init=OM$OM$lrecdevs[(25-(OM$OM$lage-1)):25],
log_recruit_devs=OM$OM$lrecdevs[26:100],
steepness=OM$OM$h,
log_R0=log(OM$OM$R0),
log_sigma_rec=log(OM$OM$sd_rec),
log_sd_catch=log(OM$sd_catch),
log_sd_index=log(OM$sd_index),
Sel_logis_k=log(OM$OM$Sel_slope),
Sel_logis_midpt=log(OM$OM$Sel_50),
log_fint=log(OM$OM$F_int[26:100]))
dyn.load(dynlib("CKMRmultinom_POP_HSP_GPP_Fisch_wAE"))
parm_names<-rep(names(par),lapply(par,length))
fixed<-list(steepness=factor(NA),log_sigma_rec=factor(NA),
log_sd_catch=factor(NA),
log_sd_index=factor(NA))
lower_bounds<-c(-5,-20,rep(-10,dat$lage),rep(-10,dat$lyear), 0, 5, -5,-5,-5,-5,-5,rep(-10,dat$lyear))
upper_bounds<-c( 2,  1,rep( 10,dat$lage),rep( 10,dat$lyear), 1, 25, 2, 2, 2, 5, 5,rep(  0,dat$lyear))
reffects=c("log_recruit_devs","log_recruit_devs_init")
l<-lower_bounds[-which(parm_names %in% c(names(fixed)))]
u<-upper_bounds[-which(parm_names %in% c(names(fixed)))]
SCAA <- MakeADFun(dat, par, DLL="CKMRmultinom_POP_HSP_GPP_Fisch_wAE", map=fixed)
OM$AE_mat
#Ncomp 5000, sdindex 0.25
N_sim<-100
Cod_wdat<-Flatfish_wdat<-Sardine_wdat<-list()
#N_comp_preCKMR<-100
N_comp_preCKMR<-c(30,rep(0,9),40,rep(0,9),50,rep(0,4),60,rep(0,4),70,rep(0,4),80,rep(0,4),90,rep(0,4),rep(100,30))
N_comp_CKMR<-5000
sd_catch<-0.05
sd_index<-0.25
fyear_dat<-26
lyear_dat<-100
prop_ckmr<-1
fyear_ckmr<-91
lyear_ckmr<-100
pi_nu<-0.736
progress_bar<-TRUE
for (s in 1:1){
Sardine_wdat[[s]] <-Get_Data(OM=Sardine_runs[[s]], dat_seed=s,fyear_dat=fyear_dat,lyear_dat=lyear_dat,sd_catch=sd_catch,N_Comp_preCKMR=N_comp_preCKMR,N_Comp_CKMR=N_comp_CKMR,q_index=0.0001,sd_index=sd_index,prop_ckmr=prop_ckmr,fyear_ckmr=fyear_ckmr,lyear_ckmr=lyear_ckmr,pi_nu=pi_nu,AE_mat="identity")
}
OM<-Sardine_wdat[[1]]
dat<-list(fyear=OM$OM$fyear, lyear=75, fage=OM$OM$fage, lage=OM$OM$lage,
years=OM$OM$fyear:75, ages=OM$OM$fage:OM$OM$lage,
obs_harv=OM$Obs_Catch,
obs_index=OM$Obs_Index,
obs_fishery_comp=OM$Obs_Catch_Comp/rowSums(OM$Obs_Catch_Comp),
SS_fishery=rowSums(OM$Obs_Catch_Comp),
Mat=OM$OM$Mat,
Laa=OM$OM$Laa,
Waa=OM$OM$Waa,
#CKMR
coded_born_year_old=OM$born_year_old-(OM$fyear_dat-1),
coded_age_diff=OM$age_diff,
n_ckmr=OM$n_ckmr,
k_ckmr_hsporggp=OM$k_ckmr_hsporggp,
coded_born_year_young=OM$born_year_young-(OM$fyear_dat-1),
k_ckmr_pop=OM$k_ckmr_pop,
samp_year_coded_old=OM$samp_year_old-(OM$fyear_dat-1),
coded_age_one=OM$coded_age_young,
coded_age_two=OM$coded_age_old,
coded_one_min=rep(0,length(OM$k_ckmr_pop)),
coded_one_max=rep(15,length(OM$k_ckmr_pop)),
coded_two_min=rep(0,length(OM$k_ckmr_pop)),
coded_two_max=rep(15,length(OM$k_ckmr_pop)),
#Switch for whether to use a data source or not, 0=no, 1=yes
Lamda_Harvest=1,
Lamda_Comp=1,
Lamda_Index=1,
Lamda_CKMR=1,
AE_mat=OM$AE_mat,
pi_nu=OM$pi_nu)
par <- list(log_M=log(OM$OM$Mref),
log_q=log(OM$q_index),
log_recruit_devs_init=OM$OM$lrecdevs[(25-(OM$OM$lage-1)):25],
log_recruit_devs=OM$OM$lrecdevs[26:100],
steepness=OM$OM$h,
log_R0=log(OM$OM$R0),
log_sigma_rec=log(OM$OM$sd_rec),
log_sd_catch=log(OM$sd_catch),
log_sd_index=log(OM$sd_index),
Sel_logis_k=log(OM$OM$Sel_slope),
Sel_logis_midpt=log(OM$OM$Sel_50),
log_fint=log(OM$OM$F_int[26:100]))
dyn.load(dynlib("CKMRmultinom_POP_HSP_GPP_Fisch_wAE"))
parm_names<-rep(names(par),lapply(par,length))
fixed<-list(steepness=factor(NA),log_sigma_rec=factor(NA),
log_sd_catch=factor(NA),
log_sd_index=factor(NA))
lower_bounds<-c(-5,-20,rep(-10,dat$lage),rep(-10,dat$lyear), 0, 5, -5,-5,-5,-5,-5,rep(-10,dat$lyear))
upper_bounds<-c( 2,  1,rep( 10,dat$lage),rep( 10,dat$lyear), 1, 25, 2, 2, 2, 5, 5,rep(  0,dat$lyear))
reffects=c("log_recruit_devs","log_recruit_devs_init")
l<-lower_bounds[-which(parm_names %in% c(names(fixed)))]
u<-upper_bounds[-which(parm_names %in% c(names(fixed)))]
SCAA <- MakeADFun(dat, par, DLL="CKMRmultinom_POP_HSP_GPP_Fisch_wAE", map=fixed)
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L3
SCAA$report()$L3
SCAA$report()$L3
SCAA$report()$L3
SCAA$report()$L3
SCAA$report()$L3
SCAA_fit <- TMBhelper::fit_tmb(obj=SCAA, startpar=SCAA$par, lower=l, upper=u, newtonsteps=1, getsd=TRUE)
SCAA$report()$L4
SCAA$report()$L4
SCAA$report()$L4
SCAA$report(SCAA$par=SCAA$env$last.par.best)$L4
SCAA$report(SCAA$env$last.par.best)$L4
SCAA$report(SCAA$par)$L4
SCAA$report(SCAA$env$last.par.best)$L4
SCAA$report(SCAA$env$last.par.best)$L4
SCAA$report()
SCAA_fit
SCAA_fit$diagnostics
compile("CKMRmultinom_POP_HSP_GPP_Fisch_wAE.cpp")
compile("CKMRmultinom_POP_HSP_GPP_Fisch_wAE.cpp")
dyn.load(dynlib("CKMRmultinom_POP_HSP_GPP_Fisch_wAE"))
parm_names<-rep(names(par),lapply(par,length))
fixed<-list(steepness=factor(NA),log_sigma_rec=factor(NA),
log_sd_catch=factor(NA),
log_sd_index=factor(NA))
lower_bounds<-c(-5,-20,rep(-10,dat$lage),rep(-10,dat$lyear), 0, 5, -5,-5,-5,-5,-5,rep(-10,dat$lyear))
upper_bounds<-c( 2,  1,rep( 10,dat$lage),rep( 10,dat$lyear), 1, 25, 2, 2, 2, 5, 5,rep(  0,dat$lyear))
reffects=c("log_recruit_devs","log_recruit_devs_init")
l<-lower_bounds[-which(parm_names %in% c(names(fixed)))]
u<-upper_bounds[-which(parm_names %in% c(names(fixed)))]
SCAA <- MakeADFun(dat, par, DLL="CKMRmultinom_POP_HSP_GPP_Fisch_wAE", map=fixed)
SCAA_fit <- TMBhelper::fit_tmb(obj=SCAA, startpar=SCAA$par, lower=l, upper=u, newtonsteps=1, getsd=TRUE)
SCAA_fit$SD$value
3728.903 *2
OM$age_diff
OM$age_diff[50:55]
compile("CKMRmultinom_POP_HSP_GPP_Fisch_wAE.cpp")
dyn.load(dynlib("CKMRmultinom_POP_HSP_GPP_Fisch_wAE"))
parm_names<-rep(names(par),lapply(par,length))
fixed<-list(steepness=factor(NA),log_sigma_rec=factor(NA),
log_sd_catch=factor(NA),
log_sd_index=factor(NA))
lower_bounds<-c(-5,-20,rep(-10,dat$lage),rep(-10,dat$lyear), 0, 5, -5,-5,-5,-5,-5,rep(-10,dat$lyear))
upper_bounds<-c( 2,  1,rep( 10,dat$lage),rep( 10,dat$lyear), 1, 25, 2, 2, 2, 5, 5,rep(  0,dat$lyear))
reffects=c("log_recruit_devs","log_recruit_devs_init")
l<-lower_bounds[-which(parm_names %in% c(names(fixed)))]
u<-upper_bounds[-which(parm_names %in% c(names(fixed)))]
SCAA <- MakeADFun(dat, par, DLL="CKMRmultinom_POP_HSP_GPP_Fisch_wAE", map=fixed)
SCAA_fit <- TMBhelper::fit_tmb(obj=SCAA, startpar=SCAA$par, lower=l, upper=u, newtonsteps=1, getsd=TRUE)
SCAA_fit$SD$value
sum(OM$samp_year_old>OM$born_year_young)
sum(OM$samp_year_old<OM$born_year_young)
sum(OM$samp_year_old=OM$born_year_young)
sum(OM$samp_year_old==OM$born_year_young)
OM$age_diff
max(OM$age_diff)
OM$samp_year_old[which(OM$age_diff==18)]
OM$born_year_young[which(OM$age_diff==18)]
OM$samp_year_old[which(OM$age_diff==17)]
OM$born_year_young[which(OM$age_diff==17)]
OM$born_year_young[which(OM$age_diff==16)]
OM$samp_year_old[which(OM$age_diff==16)]
OM$samp_year_old[which(OM$age_diff==15)]
OM$born_year_young[which(OM$age_diff==16)]
OM$born_year_young[which(OM$age_diff==15)]
SCAA_fit$SD$value
compile("CKMRmultinom_POP_HSP_GPP_Fisch_wAE.cpp")
par <- list(log_M=log(OM$OM$Mref),
log_q=log(OM$q_index),
log_recruit_devs_init=OM$OM$lrecdevs[(25-(OM$OM$lage-1)):25],
log_recruit_devs=OM$OM$lrecdevs[26:100],
steepness=OM$OM$h,
log_R0=log(OM$OM$R0),
log_sigma_rec=log(OM$OM$sd_rec),
log_sd_catch=log(OM$sd_catch),
log_sd_index=log(OM$sd_index),
Sel_logis_k=log(OM$OM$Sel_slope),
Sel_logis_midpt=log(OM$OM$Sel_50),
log_fint=log(OM$OM$F_int[26:100]))
dyn.load(dynlib("CKMRmultinom_POP_HSP_GPP_Fisch_wAE"))
parm_names<-rep(names(par),lapply(par,length))
fixed<-list(steepness=factor(NA),log_sigma_rec=factor(NA),
log_sd_catch=factor(NA),
log_sd_index=factor(NA))
lower_bounds<-c(-5,-20,rep(-10,dat$lage),rep(-10,dat$lyear), 0, 5, -5,-5,-5,-5,-5,rep(-10,dat$lyear))
upper_bounds<-c( 2,  1,rep( 10,dat$lage),rep( 10,dat$lyear), 1, 25, 2, 2, 2, 5, 5,rep(  0,dat$lyear))
reffects=c("log_recruit_devs","log_recruit_devs_init")
l<-lower_bounds[-which(parm_names %in% c(names(fixed)))]
u<-upper_bounds[-which(parm_names %in% c(names(fixed)))]
SCAA <- MakeADFun(dat, par, DLL="CKMRmultinom_POP_HSP_GPP_Fisch_wAE", map=fixed)
SCAA_fit <- TMBhelper::fit_tmb(obj=SCAA, startpar=SCAA$par, lower=l, upper=u, newtonsteps=1, getsd=TRUE)
SCAA_fit$SD$value
